\fancypagestyle{plain}{\fancyhead{}\renewcommand{\headrulewidth}{0pt}}
\chapter{Esperimenti}
Una volta ultimata l’implementazione del codice, ora più facilmente fruibile grazie alla creazione del file \textit{.lib}, il passo successivo è stato lo sviluppo di applicazioni vere e proprie che potessero fare affidamento sulla libreria Edge Engine. In particolare, in questo capitolo verranno trattati tre esperimenti differenti: il primo riguarderà un esempio di utilizzo su PC Windows (più completo e significativo rispetto a quello descritto nella sezione \ref{prova}, il secondo verterà invece sulla creazione di un plugin per poter usufruire della libreria anche in ambiente Unity3D e, infine, il terzo descriverà un vero e proprio caso applicativo portato a termine da due tesisti triennali del corso di Ingegneria Elettronica e Tecnologie dell'Informazione dell'Università degli Studi di Genova.
\section{Applicazione Windows}
L'esempio di utilizzo per Windows è stato creato al fine di mostrare e testare tutte le potenzialità offerte dall'incremento delle piattaforme supportate da Edge Engine.\\
Come accennato brevemente nella sezione \ref{prova}, in primo luogo è necessario riportare sul Cloud la descrizione della risorsa che si intende adottare. Più in particolare, sono da specificare i parametri mostrati nella tabella seguente:
\begin{table}[H]
	\begin{tabular}{|p{0.15\textwidth}|p{0.44\textwidth}|p{0.32\textwidth}|}
		\hline
		\textbf{Parametri} & \textbf{Nome} & \textbf{URL}\\
		\hline
		\textbf{Thing} & my-pc & {{url}}/v1/things/my-pc\\
		\hline
		\textbf{Feature} & total-ram, total-rom, available-ram, available-rom & {{url}}/v1/features\\
		\hline
		\textbf{Device} & pc-probe & {{url}}/v1/devices/pc-probe\\	
		\hline
		\textbf{Script} & total-rom-installed, total-ram-installed, ram-available, rom-available, average-hourly-available-ram, ram-available-to-mb, rom-available-to-mb,  max-available-ram, max-available-rom & {{url}}/v1/scripts\\	
		\hline
	\end{tabular}
\\\\url = \url{http://students.atmosphere.tools/}
	\caption{Parametri Measurify della risorsa Windows}
	\label{paramMeas}
\end{table}
Il device \textit{pc-probe} contiene all'interno della sua descrizione le features e gli script ad esso associati. Le prime indicano le grandezze fisiche misurabili dal dispositivo, mentre i secondi rappresentano le funzioni di elaborazione che è possibile applicare ai dati ricevuti. \\
La tabella \ref{script} mostra la struttura degli script implementati. Essi sono composti da due campi principali: \textit{\_id} e \textit{code}.  \textit{\_id} specifica il nome associato allo script stesso, mentre  \textit{code} contiene le effettive operazione che il dispositivo fisico andrà ad effettuare. 
\begin{table}[H]
	\begin{tabular}{|p{0.27\textwidth}|p{0.67\textwidth}|}
		\hline
		\textbf{\_id} & \textbf{code} \\
		\hline
		ram-available & available-ram().send()\\
		\hline
		rom-available & available-rom().send()\\
		\hline
		total-ram-installed & total-ram().send()\\
		\hline
		total-rom-installed & total-rom().send()\\
		\hline
		max-available-ram & available-ram(10).max().send()\\	
		\hline
		max-available-rom & available-rom(10).max().send()\\
		\hline	
		ram-available-to-mb & available-ram().map(a*1024).send()\\
		\hline
		rom-available-to-mb & available-rom().map(a*1024).send()\\
		\hline
		average-hourly-available-ram & available-ram(6m).window(+,0,10).map(a/10).send()\\
		\hline
	\end{tabular}
	\caption{Script correlati al device \textit{pc-probe}}
	\label{script}
\end{table}
Prendendo ad esempio lo script \textit{ram-available-to-mb}, il codice in oggetto permette di ricavare la quantità, espressa in gigabyte, di memoria disponibile tramite l’operazione \textit{available-ram()}, la quale viene poi concatenata a \textit{map(a*1024)} che converte il valore ottenuto in megabyte moltiplicandolo per 1024. Infine, tramite la \textit{send()} il campione appena elaborato viene inviato a Measurify.\\
Lo script \textit{average-hourly-available-ram}, invece, calcola la media oraria di ram disponibile, ma necessita di un tempo di elaborazione più lungo di una singola esecuzione dell'engine, come specificato dal codice:\\ \texttt{available-ram(6m).window(+,0,10).map(a/10).send()}\\ L’operazione \textit{available-ram(6m)} permette di campionare ogni sei minuti. Tramite la \textit{window(+,0,10)} poi, viene presa una finestra di dieci input e calcolata la somma di tali elementi. Il calcolo della media viene poi portato a termine grazie alla \textit{map(a/10)}, che opera una divisione sul totale per il numero di campioni presi in considerazione. Infine, il risultato viene inviato al Cloud grazie alla \textit{send()}.\\ 
Una volta riportata sul Cloud la descrizione della risorsa di cui si intende usufruire, è possibile passare allo sviluppo del codice dell'applicazione. Si hanno nuovamente due funzioni principali, \textit{setup} e \textit{action}, che svolgono gli stessi task di autenticazione, elaborazione e invio dei dati descritti nella sezione \ref{prova}. In questo caso però, \textit{action} viene eseguita ciclicamente per un numero di volte specificato dalla variabile \textit{loopCount}. Questo al fine di poter disporre di un tempo di esecuzione più lungo, nel caso in cui si desideri, ad esempio, usufruire dello script \textit{average-hourly-available-ram}, il quale richiede un'ora di tempo per collezionare i campioni.\\
Inoltre, al fine di recuperare dalla macchina in uso le informazioni relative all'utilizzo delle memorie RAM e ROM, sono state implementate le funzioni \textit{getRAMinfo} e  \textit{getROMinfo}. Esse sono esclusive per piattaforme dotate di sistema operativo Windows in quanto fanno uso della libreria proprietaria. Qualora si riveli necessario modificare il progetto al fine di adattarlo ad altri OS, sarà sufficiente sostituire le suddette funzioni con altre, specifiche del target desiderato.\\
Un esempio di dato elaborato dallo script \textit{ram-available-to-mb} del device \textit{my-pc} e conservato sul Cloud è mostrato in figura \ref{datowin}.
\begin{figure}[H]
	\centering
	\includegraphics[scale=0.7]{pics/datowin}
	\caption{Dato relativo al valore di memoria RAM disponibile convertito in MB e conservato sul Cloud}
	\label{datowin}
\end{figure}
\section{Applicazione alla Realtà Virtuale}
Edge Engine nasce con l’idea di offrire uno strumento modulare e slegato dall'hardware che possa facilitare e incentivare lo sviluppo di applicazioni IoT. Questo motore, oltre ad essere una valida soluzione per tale scopo, potrebbe inoltre risultare ugualmente efficace in un contesto totalmente differente, come quello dei videogiochi. Ciò è dovuto al fatto che, attualmente, non esiste uno strumento che elabori al tempo stesso dati provenienti da sorgenti così eterogenee come possono essere un sensore fisico ed uno presente all'interno di un mondo virtuale. Si pensi ad esempio ad un videogiocatore che abbia intenzione di monitorare il proprio battito cardiaco e, al contempo, processare dati provenienti dall’ambiente di gioco. Edge Engine, se adattato ad un Integrated Development Environment (IDE) dedito alla creazione di videogiochi, potrebbe essere in grado di svolgere entrambi i task richiesti grazie all’alto livello di scalabilità di cui dispone.\\
Come ultimo obiettivo, dunque, si intende trattare lo sviluppo di un’applicazione per Unity3D in modo da poter osservare il funzionamento di Edge Engine in un contesto, la realtà virtuale, diverso da quello per cui era stato inizialmente pensato, ma che può spesso rivelarsi strettamente collegato, o collegabile, all'ambiente reale.\\
In primo luogo verranno descritti i passi richiesti per la creazione di un plugin, necessario al fine di utilizzare Edge Engine all'interno dell'ambiente Unity3D. In seconda istanza poi, sarà discussa l'implementazione di un'applicazione di esempio che sfrutti il plugin in precedenza sviluppato.
\subsection{Plugin}\label{plugin}
All'interno di Unity, normalmente si utilizzano gli script C\# per creare funzionalità, ma è anche possibile includere codice creato al di fuori di Unity sotto forma di plugin. I plugin sono librerie di codice nativo specifiche della piattaforma. Possono accedere a funzionalità come chiamate del sistema operativo e librerie di codici di terze parti che altrimenti non sarebbero disponibili per Unity. Tuttavia, queste librerie non sono accessibili agli strumenti di Unity come le normali librerie utilizzabili all'interno dell’IDE. \\
Per la creazione del plugin, che corrisponde in tutto e per tutto ad una dynamic-link library (DLL), si è scelto di utilizzare Visual Studio, data l'affinità di tale IDE con Unity.\\
Dal momento che il compilatore offerto da Visual Studio, MSVC, è differente da g++, usato in precedenza per la creazione della libreria Edge Engine e l’installazione delle librerie POCO, è stato in primo luogo necessario ricompilare entrambi i progetti.\\
Per quanto riguarda le librerie POCO, in questo caso, siccome il compilatore proposto di default da VCPKG è proprio MSVC, in quanto sviluppati entrambi da Microsoft, si è deciso di utilizzare questo package manager, scegliendo la versione a 64 bit. Rispetto ai problemi riscontrati in precedenza con il compilatore g++, l’installazione delle librerie è andata a buon fine senza intoppi. Per la compilazione è necessario eseguire i seguenti comandi:
\begin{verbatim}
vcpkg install poco:x64-windows
vcpkg integrate install
\end{verbatim}
Il comando di \textit{integrate install} non è obbligatorio, ma semplifica l'utilizzo delle librerie POCO all'interno dei progetti, evitando allo sviluppatore di dover inserire le locazioni degli header e dei file \textit{.lib}, necessari alla compilazione.\\
Per quanto riguarda invece la libreria Edge Engine, è stato creato nuovamente un file \textit{.lib}, ma questa volta, facendo affidamento a MSVC per i motivi sopracitati. Per poter poi utilizzare tale libreria all'interno del progetto di creazione della DLL, è stato necessario fornire al compilatore, tramite la schermata di impostazioni di Visual Studio, la locazione degli header e del file \textit{Edgine.lib}.\\
Dopo aver messo le basi per la creazione della libreria dinamica che verrà poi utilizzata come plugin all'interno di Unity, è possibile passare alla fase di implementazione della stessa.\\
Lo schema della DLL che è stata prodotta prevede una singola classe, dentro la quale sono presenti le funzioni a cui si intenderà poi fare riferimento dal lato C\#, e il relativo header. All'interno di quest'ultimo è necessario definire tali funzioni con l’attributo \textit{\_\_declspec(dllexport)}, il quale indica che esse potranno essere chiamate dallo script che sfrutta il plugin. Inoltre, tramite la keyword \textit{extern "C"}, si indica al compilatore che le funzioni in oggetto devono impiegare la convenzione di linking del linguaggio C. Ciò è necessario al fine di esportarle correttamente, altrimenti, a causa del mangling operato dai compilatori C++, non sarebbe poi possibile far riferimento ad esse in ambiente Unity. Il mangling è una tecnica utilizzata per distinguere funzioni che hanno lo stesso nome (overloading). Essa consiste nella manipolazione del nome in fase di compilazione affinché esso sia univoco, ma, in questo specifico caso, ciò renderebbe ignoto allo sviluppatore il nome definitivo associato e, per questo motivo, non sarebbe in grado di utilizzare tali funzioni all'interno del plugin. Il linguaggio C, invece, non prevede il mangling delle funzioni, dal momento che la tecnica di overload non è supportata. Pertanto, il file binario generato dalla compilazione conterrà i nomi originali delle funzioni esportate, che potranno essere chiamate dal lato C\# senza incongruenze. Siccome la convenzione di linking adottata è quella del linguaggio C, è necessario che, nonostante il corpo delle funzioni sia scritto in C++, i tipi di dato di input e output debbano essere quelli propri del C.\\
Andando, come di consueto, a riprendere la struttura degli sketch Arduino, si è scelto di implementare due funzioni esportabili: \textit{Setup} e \textit{Action}. Il loro funzionamento è analogo ai casi precedentemente discussi, con un’importante differenza relativa all’inserimento delle caratteristiche descrittive quali \textit{device}, \textit{thing}, \textit{feature}, \textit{username} e \textit{password}. In questo specifico caso infatti, se prima tali informazioni era necessario inserirle all'interno del codice, si è scelto di renderle configurabili da parte dell'utente dal lato Unity. Di seguito sono mostrate le firme delle due funzioni in oggetto:
\begin{verbatim}
void Setup(char* myId, char* myPw, char* myThing, char* myDevice,
           char* myDeviceId)
void Action(char* sampleName, float hits)
\end{verbatim}
La \textit{Setup} prende in ingresso nell'ordine \textit{username}, \textit{password}, \textit{thing}, \textit{device}  e \textit{deviceId}, un identificativo univoco per ogni dispositivo.\\
La \textit{Action}, invece, riceve il nome della \textit{feature} e il relativo dato misurato per poterlo processare e inviare successivamente al Cloud.\\
Il progetto così compilato produce i file \textit{NATIVECPPLIBRARY.dll}, \textit{pcred.dll}, \textit{PocoFoundationd.dll}, \textit{PocoNetd.dll}, \textit{zlibd1.dll}. Il primo rappresenta proprio la libreria dinamica contenente le funzioni appena create che verranno poi utilizzate all'interno di uno script Unity. Il secondo, invece, è una DLL di file si sistema essenziali dell'OS Windows. Infine, gli ultimi tre sono un’elaborazione, operata durante la creazione della DLL, delle librerie POCO, necessarie al funzionamento di  \textit{NATIVECPPLIBRARY.dll}. Al fine di utilizzare all'interno di Unity la DLL appena creata, è necessario copiare questi files dentro la cartella di progetto.
\subsection{Unity}
\begin{figure}[H]
	\centering
	\includegraphics[scale=1.1]{pics/ring}
	\caption{Scena di gioco Unity3D}
	\label{ring}
\end{figure}
Sul fronte Unity, avendo come obbiettivo primario il test delle funzionalità di Edge Engine anche in un contesto di realtà virtuale, si è deciso di creare una semplice applicazione di esempio che potesse essere in grado di raccogliere dati provenienti dalla scena di gioco e, tramite il plugin descritto precedentemente, di inviarli a Measurify. In particolare, è stato creato un ring contenente al suo interno una pallina controllabile tramite i tasti freccia del PC (si veda fig. \ref{ring}). Ogniqualvolta la pallina urta uno dei quattro muri delimitanti, la collisione viene registrata all'interno di una variabile incrementale e, in caso di raggiungimento di un numero di collisioni che sia multiplo di cinque (lo zero è escluso per ovvi motivi), tale valore viene inviato al Cloud. Come si può facilmente dedurre, tale applicazione, differentemente da quella per Windows, rappresenta un mero esempio di utilizzo di Edge Engine all'interno dell'ambiente di gioco e non intende in alcun modo mostrare un vero e proprio caso applicativo, dal momento che non è questo lo scopo del progetto Unity.\\
In primo luogo è stato necessario inserire la descrizione della risorsa all'interno di Measurify, riassunta in tabella \ref{descunitydev}.
\begin{table}[H]
	\begin{tabular}{|p{0.15\textwidth}|p{0.30\textwidth}|p{0.46\textwidth}|}
		\hline
		\textbf{Parametri} & \textbf{Nome} & \textbf{URL}\\
		\hline
		\textbf{Thing} & ball & {{url}}/v1/things/ball\\
		\hline
		\textbf{Feature} & collision & {{url}}/v1/features/collision\\
		\hline
		\textbf{Device} & unityDevice & {{url}}/v1/devices/unityDevice\\	
		\hline
		\textbf{Script} & collisions-count-send & {{url}}/v1/scripts/collisions-count-send\\	
		\hline
	\end{tabular}
	\\\\url = \url{http://students.atmosphere.tools/}
	\caption{Parametri Measurify della risorsa Unity}
	\label{descunitydev}
\end{table}
Come spiegato in precedenza, siccome quest'applicazione è pensata per essere un semplice esempio guida, il valore associato alla sola feature \textit{collision} viene inviato così com'è, senza alcuna elaborazione intermedia.\\
Veniamo dunque allo sviluppo dello script C\# che permette la fruizione della libreria Edge Engine anche all'interno di Unity.  

\begin{wrapfigure}{r}{7.5cm}
	\centering
	\includegraphics[scale=0.85]{pics/unityscriptvars}
	\caption{Variabili settabili dall'utente}
	\label{unityscriptvars}
\end{wrapfigure}
Ricordando la struttura delle funzioni esportate dal plugin mostrata nella sezione \ref{plugin}, le quali prevedono di ricevere in ingresso i nomi dei parametri descrittivi della risorsa, oltre alle credenziali di accesso, al fine di mantenere un elevato livello di configurabilità si è scelto di impostare queste variabili come settabili da parte dell'utente dichiarandole \textit{public}, come visibile in figura \ref{unityscriptvars}. Così facendo lo sviluppatore sarà poi in grado di personalizzare a proprio piacimento i dettagli relativi al proprio caso applicativo.\\
Successivamente, per poter far uso all'interno di Unity delle funzioni \textit{Setup} e \textit{Action}, esposte dal plugin, è necessario dichiararle con l’attributo \textit{DLLImport}, come mostrato di seguito:
\begin{verbatim}
[DllImport("NATIVECPPLIBRARY", EntryPoint = "Setup")]
public static extern void Setup(StringBuilder myId, 
            StringBuilder myPw, StringBuilder myThing, 
            StringBuilder myDevice, StringBuilder myDeviceId);

[DllImport("NATIVECPPLIBRARY", EntryPoint = "Action")]
public static extern void Action(StringBuilder mySample, 
            float data);

\end{verbatim}

\begin{itemize}
	\item \textit{DLLImport} indica l'importazione da una DLL;
	\item \textit{EntryPoint} fornisce al compilatore il nome che la funzione ha all'interno del plugin;
	\item l'attributo \textit{extern} è necessario per dichiarare una funzione che è implementata esternamente.
\end{itemize}
Come è possibile notare, il passaggio dei parametri testuali avviene per lo più attraverso dati di tipo \textit{StringBuilder}. Ciò è dovuto al fatto che l’utilizzo della memoria di StringBuilder e array di \textit{char} è simile, pertanto il plugin è in grado di interpretare correttamente il contenuto del primo definito dal lato Unity. 




